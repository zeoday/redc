# 编排管理页面 Compose 模板路径显示功能

## 概述

本文档描述了在 RedC GUI 编排管理（Compose）页面中，为本地 compose 模板显示模板路径的功能设计与实现。

## 需求背景

在编排管理页面，用户选择本地 compose 模板后，需要知道该模板的实际存储路径，便于：
- 定位模板文件位置
- 手动编辑模板
- 了解模板来源

## 模板类型说明

RedC 中存在 4 种类型的模板：

| 类型 | 目录 | case.json 标记 |
|------|------|----------------|
| 预定义模板 | `aliyun`, `aws`, `huaweicloud`, `tencent` | - |
| 自定义部署模板 | `base-templates` | `is_base_template: true` |
| Userdata 模板 | `userdata-templates` | `is_userdata_template: true` |
| Compose 模板 | `compose-templates` | `is_compose_template: true` |

## 架构设计

### 数据流

```
┌─────────────────────────────────────────────────────────────────┐
│                         RedC GUI                                │
├─────────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐  │
│  │              Compose.svelte (编排管理页面)               │  │
│  │  - 加载模板列表                                           │  │
│  │  - 选择模板后显示描述和路径                                 │  │
│  └─────────────────────────┬───────────────────────────────┘  │
│                            │                                   │
│                    ┌────────┴────────┐                         │
│                    │ composeTemplates │                         │
│                    │   (lib/)        │                         │
│                    └────────┬────────┘                         │
│                            │                                   │
└────────────────────────────┼───────────────────────────────────┘
                             │
                    ┌────────┴────────┐
                    │   Wails JS      │
                    │   Bindings      │
                    └────────┬────────┘
                             │
┌────────────────────────────┼───────────────────────────────────┐
│                     Go Backend                                 │
├────────────────────────────┼───────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐  │
│  │            ListComposeTemplates (mod/tmpl.go)           │  │
│  │  - 扫描 compose-templates 目录                            │  │
│  │  - 读取 case.json 元数据                                 │  │
│  │  - 返回 ComposeTemplate 列表（含 Path 字段）              │  │
│  └─────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 关键文件

| 文件路径 | 说明 |
|----------|------|
| `mod/tmpl.go` | 后端模板加载逻辑，定义 `ComposeTemplate` 结构体 |
| `frontend/src/lib/composeTemplates.js` | 前端模板加载库 |
| `frontend/src/components/Compose/Compose.svelte` | 编排管理页面组件 |
| `frontend/wailsjs/go/models.ts` | 前端 TypeScript 模型定义 |

## 实现细节

### 1. 后端修改

**文件**: `mod/tmpl.go`

修改 `ComposeTemplate` 结构体的 `Path` 字段 JSON 标签，使其能被序列化到前端：

```go
// 修改前
Path string `json:"-"`

// 修改后
Path string `json:"path"`
```

在 `ListComposeTemplates` 函数中，Path 字段会被设置为模板目录的绝对路径：

```go
absDirPath, err := filepath.Abs(dirPath)
templates = append(templates, &ComposeTemplate{
    // ... other fields
    Path: absDirPath,
})
```

### 2. 前端模型修改

**文件**: `frontend/wailsjs/go/models.ts`

在 `ComposeTemplate` 类中添加 `path` 字段：

```typescript
export class ComposeTemplate {
    name: string;
    nameZh: string;
    type: string;
    category: string;
    description?: string;
    user?: string;
    version?: string;
    composeFile: string;
    path: string;  // 新增字段

    constructor(source: any = {}) {
        // ...
        this.path = source["path"];
    }
}
```

### 3. 前端组件修改

**文件**: `frontend/src/components/Compose/Compose.svelte`

在模板选择区域添加路径显示：

```svelte
{#if selectedTemplate}
  {@const currentTemplate = composeTemplates.find(t => t.name === selectedTemplate)}
  {#if currentTemplate?.description}
    <div class="flex-1 text-[12px] text-gray-500">
      <span class="font-medium">{(t.description || '描述')}:</span> {currentTemplate.description}
    </div>
  {/if}
  {#if currentTemplate?.path}
    <div class="flex-1 text-[12px] text-gray-400 font-mono mt-1">
      <span class="font-medium">{(t.path || '路径')}:</span> {currentTemplate.path}
    </div>
  {/if}
{/if}
```

同时修改 `handleSelectTemplate` 函数使用小写 `path`：

```javascript
function handleSelectTemplate() {
  if (!selectedTemplate) {
    composeFilePath = '';
    return;
  }
  const template = composeTemplates.find(t => t.name === selectedTemplate);
  if (template && template.path) {
    composeFilePath = template.path + '/redc-compose.yaml';
    hasManuallyPreviewed = true;
    previewCompose();
  }
}
```

## 注意事项

1. **JSON 标签命名**: Go 结构体中使用 `json:"-"` 的字段不会被序列化，如需在前端使用需要改为有效的 JSON 标签
2. **大小写转换**: Go 导出的字段（首字母大写）在 JSON 序列化时会保持大写，但前端 TypeScript 模型通常使用 camelCase，需要在构造函数中手动映射
3. **wails generate**: 某些情况下需要运行 `wails generate` 重新生成前端模型，但本例中选择了手动修改 models.ts 的方式

## 相关文档

- [Compose.md](../Compose.md) - Compose 功能说明
- [GUI_CN.md](../GUI_CN.md) - GUI 使用说明
